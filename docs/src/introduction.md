# Welcome

This is a growing set of exercises in which simple Rust programs are compiled into binaries and analyzed step by step with reverse engineering tools.

The goal is to start from the simplest possible PE binaries and gradually move toward more complex Rust applications that showcase features such as:

- Basic console I/O
- Control flow (loops, branching, pattern matching)
- Functions and modules
- Error handling
- Structs, enums, traits
- Heap allocations and dynamic memory
- Generics and lifetimes
- Concurrency and async Rust
- Integration with external libraries

